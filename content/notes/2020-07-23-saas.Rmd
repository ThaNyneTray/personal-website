---
title: SaaS - An Agile Approach to Cloud Computing
author: Desmond Tuiyot
date: '2020-07-23'
slug: saas
categories: []
tags:
  - ruby
  - rails
  - agile
  - saas
  - cloud computing
bibliography: ref.bib
---

# 1. Introduction to SaaS and Agile Development

## 1.1 Introduction

* Productivity mechanisms
  * Clarity via conciseness
  * Synthesis
  * Reuse
  * Automation & Tools

## 1.4 Service Oriented Architecture (SOA)

* The success of Agile is proven for mainly smaller projects. This success can be replicated for larger projects by using a software architecture designed to make composible services - SOA
* SOA means that components of an application act as interoperable services, and can be used independently and recombined in different applications.
* The critical distinction of SOA from siloed software is that no service/components can name or access another service's data, it can only access it through APIs
* It may take a bit more work to make compared to silos, but there's huge payback in *reusability*
* The explicit APIs also makes testing easier
* 2 widely accepted downsides:
  1. Invocation of a service involves communicating through a network interface, which results in a performance hit for SOAs
  2. Dependability planning (?) is a bit more challenging since developers now have to deal with the sticky issue of partial failures.
* The upside is that we successfully built smaller services, which allowed use of Agile (or partly due to use of Agile), and composed them to larger services. 
* SOA best exemplifies the productivity mechanism of ***reuse*** - by making services available as APIs, other developers can stand on the shoulders of those who did it before.

## 1.5 Software as a Service

* This is a special case of SOA
* It delivers the sofware and data as a service over the internet, usually via a thin wrapper like a browser that runs on the local client device, as opposed to an application binary that must be installed and runs wholly on that device. 
* **Advantages**
  1. *To customers:* they don't need to install the application, therefore don't need to worry about whether their hardware can support it or whether they have the correct version of the operating system.
  2. *To customers:* the data associated with the service lives with the service, so the customer doesn't need to worry about making backups, or losing their data due to hardware malfunction or due to loss of the device
  3. When a group of users want to collectively interact with some data, SaaS is a natural vehicle(?)
  4. When data is large and/or updated frequently, it may make more sense to centralize it and provide remote access as SaaS
  5. Only a single copy of the service runs on a uniform and tightly controlled hardware and operating system environment specified by a developer, who thus doesn't need to worry about compatibility issues of distributing software binary that has to run on different hardware and OS.
    * Developers can test new versions of software on a small portion of the customers, without disturbing the majority.
  6. Because only developers have a copy of the software, they can upgrade software and underlying hardware frequently as long as they don't violate the external API, and they also don't have to bother the customers with endless upgrade requests. 
  
## 1.6 Cloud Computing

* What's the ideal hardware for SaaS? First, let's look at requirements. SaaS places 3 demands on our IT infrastructure
  1. *Communication:* to allow any customer to interact with the service
  2. *Scalability:* the central facility running the service has to deal with fluctuations in demand during the day, during peak hours and periods of the year
  3. *Availability:* both the service and the communication vehicle must be continuously available
* The hardware that people ended up using are ***clusters.***
  * *Clusters* involve connecting a bunch of commodity computers with commodity ethernet switches and basically dedicating these to the service
    1. More scalable than conventional servers
    2. Much cheaper than conventional servers - by about a factor of 22
    3. Dependability via redundancy - if you can get it for cheap you can afford to have duplicates or even more copies - the parts aren't as dependable but you make up for it in redundancy
    4. A few operators can handle thousands of servers - if we have identical hw and sw for these servers. Virtual machines simplify operations as well

## 1.7 Legacy Code vs Beautiful Code

* *Who cares what it looks like?* is the motto of `legacy code`
* **Legacy Code** - software that does keep meeting customer needs but is hard to evolve because of design inelegance and antiquated code
  * 60% of software maintenance costs is adding new functionality to legacy code vs 17% spent of fixing bugs 
* **Beautiful Code** - does meet the customer needs AND is easy to evolve
* Apparently, legacy code is vital but often ignored in software eng classes

## 1.8 Software Quality Assurance

* Questions to think about here
  * What is software quality? How do we assure it?
  * What si V & V: Verification & Validation - what's the difference?
* **Product Quality** - In business, and in general, *Product Quality* is the "fitness of use"
  * This means business value for the *customer* and *manufacturer*
  * *Quality Assurance* is processes/standards that result in high quality and that improve the manufacturing process
* **Software Quality**
  * Satisfies the customer needs - easy to use, gets correct answers, doesn't crash
  * Easy for the developer to debug and enhance
  * Therefore, *Software QA* ensures the quality of the product and improves processes in an SW organization.
* **Quality Assurance** usually involves
  * *Verification* - did you build the thing **right**?
    * i.e. did you meet customer specifications?
  * *Validation* - did you build the **right** thing?
    * Are those the specifications correct
    * Is that what the customer wants?
  * HW focus is usually on verification, since people usually have a good idea of the specifications they want.
  * SW, on the other hand, focuses mainly on validation, since customers often don't have a clue what they want, and often get the idea once they start to see a product
* **Testing**
  * This is how we ensure software quality
  * Exhaustive testing is infeasible
  * Generally, testing is done in different phases of software development, and at different levels. Upper levels don't redo the tests of the lower level.
    * *Unit Testing* - testing that a single method does what it should
    * *Module/Functional Testing* - testing across individual units like methods/classes
    * *Intergration Testing* - putting higher level units together and checking that interfaces between units have consistent assumptions and communicate properlyy
    * *System/Acceptance Testing* - testing that the customer is satisfied with the product
  * **Black Box** vs *White Box* testing
    * *Black Box* testing just looks at the specs
    * *White Box* testing looks at the implementation
  * **Test coverage** - percentage of code paths covered
  * **Regression Testing** - automatically re-run old tests so changes don't break old code
  * **Continuous Integration Testing** - continuous regression testing on each code check-in rather than in a later testing phase

## 1.9 Productivity

* **Clarity via Conciseness** - banking on concise code. Write small amounts of code that gets transformed into large amounts of information.
  1. Syntax: shorter and easier to read
    ```{ruby eval=F}
    assert_greater_than_or_equal_to(a, 7)
    a.should be >= 7
    ```
  2. Raise the level of abstraction
    * It's why high level languages were built - vs assembly
    * Ideas like automatic memory management (Java vs C) - turns out there's lots more bugs if you manage memory manually
    * Scripting languages like R have these ideas like *metaprogramming* and *reflection* that raise the level of abstraction.
* **(Code) Synthesis** - basically generated code. 
  * This involves generating the code you'll use rather than write it yourself
    * An example is BitBlt which generates code to fit the situation rather than have conditional tests.
    * Programming by example - Excel generating a macro from an example you give it
* **Reuse** - reusing code that's been written before
  * The idea is to reuse old code vs write new code
  * Techniques we've used in historical order
    1. Procedures and Functions
    2. Standardized Libraries
    3. OOP
    4. Design Patterns - strategy to reuse even if implementation varies.
* **Automation & Tools**
  * This involves building tools to automate tedious manual tasks, improving accuracy
  * **Concerns** with new tools - Are they Dependable? Good UI? Picking one from several
  * SE dooms you to lifetime learning. 
* **DRY** - Don't Repeat Yourself
  * *"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system"*
    - Andy Hunt and Dave Thomas, 1999
  * So Don't Repeat Yourself
  * Refactor code so that 


## 1.2, 10.7 SW Development Processes: Plan & Document

* These processes included **Waterfall**, **Spiral**, and **RUP**.
* The term of bringing *engineering discipline* to software development came about after some infamous software failures. The idea was to try and make software engineering as predictable and dependable as civil engineering, for example. 
  * The term **software engineering** was first coined in 1979
* **Plan & Document** - this is the initial approach
  * Before coding, project manager makes a plan
  * Write detailed documentation of all phases of the plan
  * Progress is measured against the plan
  * Changes to the project must be reflected in the documentation and possibly the plan
* **1st Development Process: Waterfall (1970)** - 
  * There were 5 phases of the waterfall *cycle*
    1. Requirements analysis and specification - analyze requirements and codify that into specifications
    2. Architectural Design
    3. Implementation & Intergration - actually making the software and putting the different pieces together. 
    4. Verification - making sure that the software does what the specifications dictate
    5. Operation & Maintenance
  * The idea was to complete one stage before moving on to the next one
    * Finding bugs in earlier stages is much cheaper
  * Since the development process took so long, the extensive documentation was for new engineers coming onto the project to quickly catch up
  * **How well does it work?**
    * The customer specifications change frequently on seeing the product
      * *And the users exclaimed with a laugh and a taunt: "It's just what we asked for, but it's not what we want"*
      *- Anonymous*
    * Often after building the first implementation, developers learn how they should build it better
      * *"Plan to throw one [implementation] away; you will, anyhow."*
        *- Fred Brooks Jr (1999 Turing Award Winner)*
  * These disadvantages inspired the next approach
* **2nd Development Process: Spiral (1986)**
  * This one aimed to combine the *Plan and Document* approach with *prototypes*
  * The idea was, rather than plan and document all requirements first, do this for each iteration of the prototype as needed and let it evolve the project 
  * For each iteration, the process was as such:
    1. Determine objectives & constraints
    2. Evaluate alternatives (to what?) and identify any risks to the project and how to resolve it.
    3. Develop the prototype and verify it with the customers
    4. Plan next iteration based on feedback from the customers as well as what was gleaned from that iteration
  * **What's the good?**
    * Iterations involve the customers before the product is completed, therefore there was a lower chance of misunderstandings.
    * Risk management is part of the development lifecycle
    * Project monitoring is easy (is it?)
    * Schedule and cost estimates become more realistic over time.
  * **What's the bad?**
    * Iterations could be anywhere beteen 6 to 24 months, which is plenty of time for customers to change minds
    * Lots of documentation for each iteration - during each one, you have to write new sets of documentation
    * Lots of rules to follow for the whole project
    * Cost of process is high because of the documentation and building the prototypes
    * Pretty hard to meet the budget and schedule targets. 
* **3rd Development Process: Rational Unified Proces (RUP - 2003)**
  * There's 2 ideas interacting here - one consists of the *RUP phases*, and the other includes the *engineering requirements/disciplines*
  * **Four Phases**
    1. **Inception**
      * We make a business case for the software - why make that investment and what would be the ROI
      * Set the schedule and the budget
      * Perform a risk assessment and try to ameliorate them
    2. **Elaboration**
      * Develop the use cases of the app
      * Start to develop the software architecture
      * Build the first basic prototype
    3. **Construction**
      * Coding, testing and the first product release
    4. **Transition**
      * Move to the real environment where the sw should be running
      * Get customer acceptance
  * **Engineering Disciplines** - these you'll need over the course of the lifecycle - the importance of each varies across phases
    1. Business Modelling
    2. Requirements
    3. Analysis & Design
    4. Implementation
    5. Test
    6. Deployment
  * **What's the good?**
    * The first phase ties the business practices more closely to the development process
    * Lots of tools called *Computer Aided Software Engineering Case Tools* from Rational, which has now been bought out by IBM. 
    * The tools support gradual improvement of the project over time
  * **What's the bad?**
    * The tools are very expensive and there is no open source version
    * There's so many options to tailor RUP to a company, so one may end up not using all the tools
    * Tends to be only good for medium to large scale projects since there's a lot of overhead and is expensive
    * It's up to the manager to decide how long an iteration within one of the phases will be.
* **P&D Project Manager: Processes Expect a Strong Project Manager**
  * Writes the contract to win the project from the customer
  * Recruits the development team
  * Evaluate software engineering performance, which affects the salary
  * Estimate costs, maintaining schedule, evaluating risks and how to overcome them
  * Document all of this in the document plan
  * Gets credit for success and blame if it goes over budget or is late.
* **P&D Team Size**
  * Teams tend to get bigger primarily through expansion (how else?)
    *"Adding manpower to a late project makes it later" - Fred Brooks, Jr.*
  * It takes time for people to learn new projects
  * Communication time grows with the team size, leaving less room for work
  * These teams tend to be of about 4-9 people, but hierarchically composed for larger projects
    
    
## 1.3 SW Development Processes: The Agile Manifesto

* The **Agile Manifesto** in 2001 was perhaps the "Reformation moment" in Software development, where the Agile Alliance declared:  
  "*We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:*
  * ***Individuals and interactions** over processes & tool*
  * ***Working software** over comprehensive documentation*
  * ***Customer collaboration** over contract negotiation*
  * ***Responding to change** over following a plan*  
  *That is, while we value the items on the right, we value the items on the left more*"
* The *Extreme Programming (XP)* flavor of Agile - essentially, if a certain thing is good, lean into it even more
  * If short iterations are good, make them as short as possible (weeks vs years)
  * If simplicity is good, always do the simplest thing that could possibly work
    - Don't anticipate complexity, but do the minimum you have to to get done
  * If testing is good, test all the time. In fact, go ahead and write the test before writing any code
  * If code reviews are good, review code continuously by programming in pairs, taking turns and constantly looking over each other's shoulders.
* **Agile lifecycle** - Agile embraces change as a fact of life.
* Developers focus on improving working but incomplete prototypes, with the customer giving feedback at each iteration until the customers are happy. It emphasizes:
  * **TDD** to reduce mistakes by writing the tests before the code
  * **User Stories** to reach an agreement and validate the customer's requirements
    * Documentation is primarily through user stories & test cases
  * **Velocity** to measure progress - this is the rate that a project completes features
* Iterations and prototypes are put out pretty quickly - it may take a week or 2. 
* **Book Organization**
  * Parts 2-6 - SaaS
  * Parts 7-12 - Agile
* **Agile Iteration**
  1. Talk to "Customer"
  2. Behavior Driven Design: User Stories
  3. Test Driven Development: Unit Tests
  4. Measure Velocity
  5. Deploy to Cloud
  * Design Patterns
  * Legacy Code
* **Agile (No) vs P&D (Yes) checklist**
  1. Is specification required?
  2. Are customers unavailable?
  3. Is the system to be built large?
  4. Is the system to be build complex?
  5. Will it have a long product lifetime?
  6. Are you using poor software tools?
  7. Is the project team geographically distributed?
  8. Is the team part of a document-oriented culture?
  9. Does the team have poor programming skills?
  10. Is the system to be built subject to regulation?
  
  
## 1.12/13 Fallacies & Pitfalls

* *Fallacy:* Agile is best for SW development.
  * It's good for SaaS, but not for some software, like government regulated software for example
  * Per topic, will practice the Agile way, but will see the P&D perspective. 
* *Pitfall:* Ignoring the cost of software design
  * Since manufacturing cost is 0 for software, might believe it's also 0 to remanufacture how the customer wants
  * This also ignores the cost of design and test
  
## 10.1 Size & Scrum

## 10.2 Pair Programming

# 3. SaaS Framework: Introduction to Ruby
## 3.1 Overview & Three Pillars of Ruby

* Let's start with this laundry list: Ruby is:
  * An ***interpreted language*** - so you don't have to compile it
  * It's ***object oriented***
    * *Everything** is an ***object***
    * Every operation is a ***method** called on some object
  * It's ***dynamically typed***: objects have types but variables don't
  * It's a ***dynamic language***
    * allows you to add & modify code at runtime ***(metaprogramming)***
    * can ask objects about themseles ***(reflection)***
    * in a sense *all* programming is *metaprogramming*
* *symbols* vs *strings* use case
  * Symbols denote specialness. Whenever a method takes in a symbol, it could imply that that symbol is one of a small number of inputs that that method could understand, and it is not prepared to deal with arbitrary strings.
* **Methods**
  * Everything except fixnums(integers) is passed by reference
  * When a method returns an array of stuff, you can call it and assign it to a single variable, which will then be an array, or you can assign it to a list of variables.
* **Basic Constructs**
  * Statements can end with a new line or a semi colon - but prefer to use newline if parsing is unambiguous
    * Below we have 2 duplicate statements, but one of them is wrong because of where the line break is placed.
      ```{ruby eval=F}
      # correct linebreak
      raise('Boom') unless
        ship_stable
      
      # incorrect linebreak
      raise ('Boom')
        unless ship_stable
      ```
    * Essentially, `raise('Boom')` is a valid ruby statement, so it evaluates it on its own because of the newline. Don't make this mistake
  * Basic comparisons and Operators
    * `=~`, `!~` - are used in regular expressions. 
* **Strings and Regular Expressions**
  * `"string"`,`%Q{string}`,`'string'`,`%q{string}`
    * The advantage of the %Q/q representation is you can then add double quotes/single quotes without having to escape the string.
  * With double quoted strings, you can interpolate an *expression* into the string. With single quoted strings, though, you can't. 
  * matching a string with a regexp:
    ```{ruby eval=F}
    "dtuiyot@colgate.edu" =~ /(.*)@(.*)\.edu/i
    
    #OR
    
    /(.*)@(.*)\.edu/i =~ "dtuiyot@colgate.edu"
    ```
    * These expressions will return true. 
    * If no match, value is false
    * If it's a match, value is non-false, and `$1, $2, ... $n` capture parenthesized groups - $1 => "dtuiyot", $2 => "colgate
  * The slashes `/ ... /` are the most common idiom for writing regular expressions. You can also use `%r{(.*)$}i` or `Regexp.new('(.*)$', Regexp::IGNORECASE)`

# 3.2/3 Everything is an Object, Every Operation is a Method Call

* Even the lowly integer and nil are objects and the only way to get shit done is to call methods on these objects.
  ```{ruby eval=F}
  5.days.ago # will get you how many seconds since from 5 days ago
  50.methods # will ask how what kind of methods the number can respons to
  34.respond_to?(:to_sym) # ask if a number responds to that method specifically
  ```
* Essentially, all the operations or methods are just syntactic sugar around the `send` language primitive. This says *"take this `method` and send it to the `receiver` (the object)."*
* Here ruby only cares about whether this receiver knows how to handle that method.
  ```{ruby eval=F}
  1 + 2 # => 1.send(:+, 2)
  my_str.length       => my_str.send(:length)
  my_array[4]         => my_array.send(:[], 4)
  my_array[3] = 'foo' => my_array.send(:[]=, 3, "foo")
  if (var==2)...      => var.send(:==, 2)
  my_func(z)          => self.send(:my_func, z)
  ```
  * `self` here is an implicit receiver. 
* ***REMEMBER***
  * **a.b** means: method call **b** on object **a**
    * **a** is the *receiever* to which you *send* that method, assuming that **a** can/will *respond to* that method
  * **a.b** does not mean:
    * **b** is an instance variable of **a**
    * **a** is a data structure and **b** is a member
* **Poetry Mode in Action**
  * It'll get more natural and intuitive to figure out when to leave out parenthesis and/or braces. If the parser doesn't get confused, it's fine to do it and then it'll read just like English.
  * When parenthesis are optional, i.e. when the parsing is clear, Ruby allows us to omit parenthesis
  * When the context is unambiguous, we can also omit braces around hashes.
  
# 3.4 Ruby OOP

Some clarifications
* There is no notion of a public instance/class variable - to access this you need to define a *setter*.
  ```{ruby eval=F}
  ...
  # For class variables
  @@bank_name = "NBT"
  def self.bank_name
    @@bank_name
  end
  
  # OR
  def NameOfClass.bank_name
    @@bank_name
  end
  
  @balance = 4
  def balance
    @balance
  end
  ...
  ```
* Shortcut to the getters/setters is the `attr_accessor` method - which simplifies that code. This method uses *metaprogramming* - when you call `attr_accessor`, you are essentially asking for Ruby to create those two methods that you replaced.

**Review: Ruby's Distinguishing Features**
* Highly Object Oriented
  * everything is an object
  * class, instance variables are invisible outside class (use getters/setters)
  * no multiple inheritance - instead, *mixins* are used
* Everything is a method call
  * usually only care whether receiver responds to that call
  * most "operators" are really just instance methods
  * dynamically typed: objects have types, variables don't
* Expression-orinted: most methods nondestructive
  * e.g. [array] + [array] returns new object
  * Exceptions - `<<`, some destructive methods (`sort` vs `sort!`)
* Evidently, you **CAN** add methods to an in built object



    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      














# References
  


